###image
1.作为next特供的元素，有几个元素必填，width,height,alt,注意不可带单位，只接受数字，并且默认懒加载，并且有一个特殊的值,quality,可以确认获得图片的品质1-100，100为满。
注意需要在next.config.mjs当中添加可以访问的网址。
2.可以通过导入静态资源的办法避免填写width,height,属性fill可以动态填满窗口，placeholder="blur",先展示模糊，后有数据以后展示图片。
###路由
1.在app下的文件夹在名字前加入一个"_"即可避免纳入路由
###服务器组件
1.使用服务器组件可以不使用useEffect(虽然也用不了hook)初始化数据,因为第一次返回的html,css,js就已经是包含了数据。
而react则一开始只有一个空的dom节点，需要获得数据以后处理成为新的html,css,js。
###服务器操作
1.可以在服务器组件定义服务器操作，可以通过use server定义服务器组件，然后这里的所有函数都是服务器操作。
2.因为服务器操作不会发送给后端，所以这意味着可以直接写数据库操作或者api秘钥，这是安全的。
###动态路由
1.在对应文件夹下使用中括号包裹任意文字，可以在该文件夹下的page页面解构获得parmas,渲染对应的页面，注意query与这个无关
###错误处理
1.在app文件夹下创建一个error.js以处理出现的错误，如结构出的动态路由获取的后端数据是有问题的，可以捕获这种错误，接受error
,reset(重载函数)显示这个页面（所有错误处理都是"use client";）。
2.不能捕获layout当中的错误，如果真的需要的话，要创建一个golbal-erroer.js
3.not-found.js可以用于处理找不到页面时的情况，渲染对应的组件替代。可以自动调用，也可以手动调用：使用内置函数notFound()，例如子组件查询路由不存在抛出一个错误，
这时捕获错误并且调用该函数即可。
###动态路由转化静态路由
1.当数据有限的情况下将动态的路由转化为静态的总是一个好主意，对于性能也是一个提升。如在动态路由的页面导出generateStaticParams，返回所有的parmas是一件好事。
2.缺陷，使用完全静态路由以后打包的静态网页无法使用image的quality,因为这是服务端渲染的处理的，需要使用img替代或者使用其他的网站动态处理如coluldfare
###缓存（更多查看d盘图片）
1.在客户端存在一个路由缓存，在路由变化时不会重新获得后端数据，而是沿用旧数据，在动态路由的时候缓存30s,静态路由缓存5min,可以在使用上看起来像单页应用，但是会造成数据上的滞后性。
2.注意，在开发环境下几乎不会有缓存
3.导出revalidate可以帮助清除数据缓存，设置一个时间，单位为秒，注意，需要立刻获得有效数值而不是通过计算之类获得的数值。
4.清除浏览器缓存，revalidatePath("/account");//发送这个意味着浏览器更新
###数据流通
1.客户端组件不可以导入服务端组件，只能导入服务端组件，并且只能渲染服务端组件和客户端组件作为一个props(子组件也是children prop)
2.服务端组件可以导入服务端组件和客户端组件并且可以任意渲染。
3.一般来说为了更好地性能需要尽可能的多使用服务端组件。有一些组件仅仅是作为静态ui呈现的，放在服务端组件就是服务端渲染，放在客户端组件就是客户端渲染。
所以可以尽可能的暴漏在服务端组件当中，以成为服务端组件。
###服务器组件与客户端组件通信
1.服务器组件向客户端组件传参十分简单，只需要正常的传入即可，但是客户端组件却不好向服务端组件传入数据，以下会列举一些办法。
a.最简单的当然是使用路由传参。例如页面可以结构出searchParams，修改路由可以使用web api,URLSearchParams创建一个实例+useRouter来控制。
2.将服务端组件包裹在客户端组件里面，看起来反直觉，其实是可行的，只不过是通过在传入一个children来使用，作为一个layout,实际上是在其他组件实现这种强行传入的。
###中间件
1.在数据与路由之间。
2.导出config可以只在部分路由使用。使用matcher即可。
###suspense
1.可以传入不同的key来确保触发，可用于过滤一些数据后切换数据加载时不触发suspnese的问题。
###api在老项目的作用
1.使用router.js作为文件名，内置GET,POST等函数，发起/api请求可以获得对应数据，可以使用Response.json()。
###其他：
1.使用suspense的时候，子组件移动到Activity,同时将fallback加入到兄弟节点，当Activity执行完成以后会影长fallback，加入子组件，在这个过程中fiber tree一直包含这两个组件，
但是在实际中看起来就像丢弃了一样。这个过程父组件如果知道子组件是否加载完成呢，子组件会抛出一个promise,throw new promise,最近的suspense会接住这个promise。
2.小技巧，当页面同时发起几个请求的时候显然会await阻塞起来，可以使用promise.all来解决
——————————————————————————————————————————————————————————————————————————————
——————————————————————————————————————————————————————————————————————————————
____________________________________________________________________________________________________________________________________________________________
实际开发：
1.nextjs是全栈，它可以无风险的使用某些重要的api,甚至操作数据库。比如用户可以访问网址，或者客户端网页，客户端网页基于服务端生成，服务端基于某些特殊的api/数据库操作生成。
相当于架起了桥梁。某些时候为了便于部署静态网页，不能使用/api等后端特性，并且因为某些api无法在公网使用，所以也不能在客户端请求。所以只能提前构建静态页面。这个时候似乎就
只有一个办法了。那就是通过/page来做到静态页面部署。